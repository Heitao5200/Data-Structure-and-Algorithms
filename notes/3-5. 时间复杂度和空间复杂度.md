# 时间复杂度和空间复杂度

## 算法效率的度量方法

### 事后统计方法

这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。

- 缺陷：
  - 必须依据算法事先编制好测试程序，通常需要花费大量时间和精力，完了发觉测试的是糟糕的算法，那不是功亏一篑？赔了娘子又折兵？
  - 不同测试环境差别不是一般的大！

### 事前分析估算方法

在计算机程序编写前，依据统计方法对算法进行估算。

- 高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：
  - 算法采用的策略，方案
  - 编译产生的代码质量
  - 问题的输入规模
  - 机器执行指令的速度

一个程序的运行时间依赖于算法的好坏和问题的输入规模。

- 第一种算法

`sum,n = 0,100
for i in range(n+1):
    sum = sum + i
print(sum)
`

- 第二种算法

`sum , n  =  0,100
sum  = (1+n)*n/2
print(sum)`

我们研究算法的复杂度，侧重的是研究算法随着输入规模扩大增长量的一个抽象，而不是精确地定位需要执行多少次，因为如果这样的话，我们就又得考虑回编译器优化等问题，然后，然后就永远也没有然后了！
所以，对于刚才例子的算法，我们可以果断判定需要执行100^2次。

在分析程序的运行时间时,不计那些循环索引的递增和循环终止条件、变量声明、打印结果等操作。最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。把基本操作的数量和输入模式关联起来。

## 函数的渐近增长

### 测试1

假设两个算法的输入规模都是n，算法A要做2n+3次操作，你可以这么理解：先执行n次的循环，执行完成后再有一个n次的循环，最后有3次运算。

![](J:/HeitaoGit/Data-Structure-and-Algorithms/img/3.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E6%B5%8B%E8%AF%951-1.PNG)

- 当n=1时，算法A1效率不如算法B1；
- 当n=2时，两者效率相同；
- 当n>2时，算法A1就开始优于算法B1了，随着n的继续增加，算法A1比算法B1逐步拉大差距。
- 所以总体上算法A1比算法B1优秀。

![](J:/HeitaoGit/Data-Structure-and-Algorithms/img/3.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E6%B5%8B%E8%AF%951-2.PNG)

- 函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。

- 随着n的增大，例如算法A2，B2，在图中他们压根儿被覆盖了。所以，我们可以忽略这些加法常数。

  

### 测试2

![](J:/HeitaoGit/Data-Structure-and-Algorithms/img/3.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E6%B5%8B%E8%AF%952-1.PNG)

![](J:/HeitaoGit/Data-Structure-and-Algorithms/img/3.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E6%B5%8B%E8%AF%952-2.PNG)

- 哪怕去掉与n相乘的常数，两者的结果还是没有改变，也就是说，与最高次项相乘的常数并不重要，也可以忽略。

### 测试3

![](J:/HeitaoGit/Data-Structure-and-Algorithms/img/3.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E6%B5%8B%E8%AF%953-1.PNG)

![](J:/HeitaoGit/Data-Structure-and-Algorithms/img/3.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E6%B5%8B%E8%AF%953-2.PNG)

- 我们通过观察又发现，最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快。

### 测试4

![](J:/HeitaoGit/Data-Structure-and-Algorithms/img/3.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E6%B5%8B%E8%AF%954-1.PNG)

![](J:/HeitaoGit/Data-Structure-and-Algorithms/img/3.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E6%B5%8B%E8%AF%954-2.PNG)

- 当n的值变得非常大的时候，3n+1已经没法和2n^2的结果相比较，最终几乎可以忽略不计。而算法G在跟算法I基本已经重合了。

### 结论

判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高项）的阶数。

## 算法时间复杂度的定义

在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。

**总结为一句话：算法的执行次数==时间**

我们用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。
一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。

## 推导大O阶方法
- 用常数1取代运行时间中的所有加法常数。
- 在修改后的运行次数函数中，只保留最高阶项。
- 如果最高阶项存在且不是1，则去除与这个项相乘的常数。
- 得到的最后结果就是大O阶。

### 常数阶
并不是有多少条语句就是O几，所有加法常数给他个O(1)即可
### 线性阶
一般含有非嵌套循环涉及线性阶，线性阶就是随着问题规模n的扩大，对应计算次数呈直线增长。
它的循环的时间复杂度为O(n)，因为循环体中的代码需要执行n次。
### 平方阶
`i = 0
n = 100
for  i in range(n+1):
     for j in range(n+1):
         print("I love FishC.com\n")
         `
n等于100时，外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环出来，需要执行100*100次，也就是n的平方。所以这段代码的时间复杂度为O(n^2)。

`i = 0
 n = 100
 for  i in range(n+1):
     for j in range(n+1 - i):
         print("I love FishC.com\n")
         `
由于当i=0时，内循环执行了n次，当i=1时，内循环则执行n-1次……当i=n-1时，内循环执行1次，所以总的执行次数应该是：
$$
n+(n-1)+(n-2)+…+1  = \frac{n(n+1)}{2} = \frac{n^2}{2}+\frac{n}{2}
$$
因为没有常数相加。第二条只保留最高项，所以$\frac{n}{2}$这项去掉。第三条，去除与最高项相乘的常数，最终得$O(n^2)$。
         
### 对数阶
`
i = 1
n = 100
while i < n:
    i = i * 2
    print(i)
`
由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于或等于n，则会退出循环。于是由$2^x = n$得到$x = log(2)n$，所以这个循环的时间复杂度为$O(logn)$

## 算法的空间复杂度

### 函数调用的时间复杂度分析

`def function(count):
     print("{}".format(count))
 n = 100
 for i in range(n+0):
     function(i)
     `
function函数的时间复杂度是O(1)，所以整体的时间复杂度就是循环的次数O(n)。

`def function(count):
     print("{}".format(count))
 n = 100
 for i in range(n+0):
     function(i)
     `
这和之前我们讲解平方阶的时候举的第二个例子一样：function内部的循环次数随count的增加(接近n)而减少，所以根据游戏攻略算法的时间复杂度为O(n^2)。
`n = n + 1
 function2(n)
 for i in range(n+0):
     function2(i)
 for i in range(n+0):
     for j in range(n+0-i):
         print(j)
         `
![](J:/HeitaoGit/Data-Structure-and-Algorithms/img/5.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E4%BE%8B1.png)

### 常见的时间复杂度

![](J:/HeitaoGit/Data-Structure-and-Algorithms/img/5.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png)

![](J:/HeitaoGit/Data-Structure-and-Algorithms/img/5.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E6%9C%89%E5%9B%BE%E6%9C%89%E7%9C%9F%E7%9B%B81.jpg)
![](J:/HeitaoGit/Data-Structure-and-Algorithms/img/5.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E6%9C%89%E5%9B%BE%E6%9C%89%E7%9C%9F%E7%9B%B82.jpg)

- 常用的时间复杂度所耗费的时间从小到大依次是：
  O(1) < O(logn) < (n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

### 最坏情况与平均情况

- 查找一个有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置，那么时间复杂度为O(n)。
- 平均运行时间是期望的运行时间。
- 最坏运行时间是一种保证。在应用中，这是一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间。

## 算法的空间复杂度

在写代码时，完全可以用空间来换去时间。

### 举个例子

要判断某年是不是闰年

- 方法一：
  - 写一个算法，每给一个年份，就可以通过这个算法计算得到是否闰年的结果。
- 方法二：
  - 事先建立一个有2050个元素的数组，然后把所有的年份按下标的数字对应，如果是闰年，则此数组元素的值是1，如果不是元素的值则为0。这样，所谓的判断某一年是否为闰年就变成了查找这个数组某一个元素的值的问题。

方法一相比起方法二来说很明显非常节省空间，但每一次查询都需要经过一系列的计算才能知道是否为闰年。第二种方法虽然需要在内存里存储2050个元素的数组，但是每次查询只需要一次索引判断即可。

算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。